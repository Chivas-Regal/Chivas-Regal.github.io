---
layout: post
title: 主席树
subtitle: 要可以直接访问到每一次线段树的改变？🤔
categories: 数据结构
tags: [数据结构]
---

<head>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
	</style>
        <style>
		.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
	</style>
</head>
<body class="vscode-body vscode-light">
        <h2 id="定义">定义</h2>
<p>可持久化线段树也叫<span style="color: red;">函数式线段树</span>、主席树<br>
其对于每个修改并不是直接对一个节点更改它的值<br>
而是对于这个节点额外创建一个节点表示它修改后的值，也被称为一个新的版本节点<br>
对于这个版本节点，依然<span style="color: red;">可以直接访问它的左右子节点、也可以直接访问它</span></p>
<h2 id="可持久前提">可持久前提</h2>
<p>本身的拓扑结构在整个操作中保持不变</p>
<blockquote>
<p>树状数组，线段树，字典树，并查集，堆....都满足<br>
但平衡树不可，平衡树有左旋右旋，节点之间的拓扑序会变</p>
</blockquote>
<h2 id="操作">操作</h2>
<h3 id="查询">查询</h3>
<p>对于每次查询，我们需要<span style="color: red;">确定版本</span><br>
对于某个版本下的树，利用线段树的二分性质，二分地向下查询（和普通的差不多）</p>
<h3 id="修改">修改</h3>
<p>每次单点修改会改变<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span></span></span></span>个节点<br>
因为向下递归，找到要修改的点后，一步步向上<br>
<span style="color: red;">从当前节点到根节点</span>的一条路径上都要修改</p>
<p>区间修改很难实现，懒标记可以采用永久化懒标记进行维护</p>
<h2 id="经典问题区间第k小">经典问题：区间第k小</h2>
<p><a href="https://www.luogu.com.cn/problem/P3834"><img src="https://i.loli.net/2021/09/23/Hi18j6T7kqRYOhl.png"></a></p>
<h3 id="前置知识权值线段树">前置知识：权值线段树</h3>
<p><b><span style="color: red;">对值域内每个数出现的次树建立线段树</span></b></p>
<blockquote>
<p>比如说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mspace width="0.277778em"></mspace><mn>1</mn><mspace width="0.277778em"></mspace><mn>2</mn><mspace width="0.277778em"></mspace><mn>2</mn><mspace width="0.277778em"></mspace><mn>3</mn><mspace width="0.277778em"></mspace><mn>3</mn><mspace width="0.277778em"></mspace><mn>3</mn><mspace width="0.277778em"></mspace><mn>3</mn><mspace width="0.277778em"></mspace><mn>4</mn><mspace width="0.277778em"></mspace><mn>5</mn></mrow><annotation encoding="application/x-tex">1\;1\;2\;2\;3\;3\;3\;3\;4\;5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mspace thickspace"></span><span class="mord mathrm">1</span><span class="mord mspace thickspace"></span><span class="mord mathrm">2</span><span class="mord mspace thickspace"></span><span class="mord mathrm">2</span><span class="mord mspace thickspace"></span><span class="mord mathrm">3</span><span class="mord mspace thickspace"></span><span class="mord mathrm">3</span><span class="mord mspace thickspace"></span><span class="mord mathrm">3</span><span class="mord mspace thickspace"></span><span class="mord mathrm">3</span><span class="mord mspace thickspace"></span><span class="mord mathrm">4</span><span class="mord mspace thickspace"></span><span class="mord mathrm">5</span></span></span></span>这个序列<br>
会形成这样一棵权值线段树<br>
<img src="https://i.loli.net/2021/09/23/Yo1PiewFNVyns6W.png"><br>
想要求得此序列中的第k小，此时利用权值线段树的性质<br>
我们可以<span style="color: red;">二分地</span>往下走<br>
若左侧的个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\ge k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mrel">≥</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，走左侧<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><br>
若左侧的个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\lt k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">&lt;</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，走右侧<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>−</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>l</mi></msub><mi>e</mi><mi>f</mi><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(k-cnt_left)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span><br>
走到最后就是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>小</p>
</blockquote>
<h3 id="快速求区间权值线段树">快速求区间权值线段树</h3>
<p>由于是区间查询<br>
所以可以联想到<span style="color: red;">前缀处理</span><br>
即构建一棵前缀的权值线段树<br>
那么我们在<span style="color: red;">访问区间权值线段树时，可以两个前缀相减快速求得</span><br>
<b>相减操作包括访问操作，都可以用主席树去实现</b><br>
对于序列中的每一个离散化之后的数，我们都可以将<span style="color: red;">插入视作建立一个新版本</span><br>
在查询区间的时候只需要<span style="color: red;">查询两个版本</span>即可</p>
<h3 id="程序">程序</h3>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> a[N];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> {</span>
        <span class="hljs-keyword">int</span> l, r, sum;
}sgtr[N * <span class="hljs-number">30</span>];
<span class="hljs-keyword">int</span> tot, root[N];

<span class="hljs-comment">// 访问x离散化之后的值</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_Id</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{
        <span class="hljs-keyword">return</span> lower_bound(nums.begin(), nums.end(), x) - nums.begin() + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// 在表示[l, r]区间的now节点插入数字p，上个版本是pre</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> &amp;now, <span class="hljs-keyword">int</span> p )</span> </span>{
        sgtr[++ tot] = sgtr[pre];       <span class="hljs-comment">// 很多信息一样，剩下的改改就行</span>
        now = tot;                      <span class="hljs-comment">// 当前节点编号 = 新分配的节点编号</span>
        sgtr[now].sum ++;               <span class="hljs-comment">//这个节点数字的个数+1</span>
        <span class="hljs-keyword">if</span> ( l == r ) <span class="hljs-keyword">return</span> ;          <span class="hljs-comment">// 叶子节点</span>

        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( p &lt;= mid )                 <span class="hljs-comment">// 插入什么数 = 在线段树哪一个位置插入</span>
                Insert(l, mid, sgtr[pre].l, sgtr[now].l, p);
        <span class="hljs-keyword">else</span>
                Insert(mid + <span class="hljs-number">1</span>, r, sgtr[pre].r, sgtr[now].r, p);
}

<span class="hljs-comment">// 查询版本R-版本L-1，两个版本同步进行，当前到达节点表示区间[l,r]，查询第k大</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Query</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> k )</span> </span>{
        <span class="hljs-keyword">if</span> ( l == r ) <span class="hljs-keyword">return</span> l;

        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> cnt = sgtr[sgtr[R].l].sum - sgtr[sgtr[L].l].sum; <span class="hljs-comment">// 新减出的线段树的左子树有多少个数</span>
        <span class="hljs-keyword">if</span> ( k &lt;= cnt )
                <span class="hljs-keyword">return</span> Query(l, mid, sgtr[L].l, sgtr[R].l, k);
        <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> Query(mid + <span class="hljs-number">1</span>, r, sgtr[L].r, sgtr[R].r, k - cnt);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>
        freopen(<span class="hljs-string">&quot;../in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
        freopen(<span class="hljs-string">&quot;../out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int</span> n, m; <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) {
                <span class="hljs-built_in">cin</span> &gt;&gt; a[i];
                nums.push_back(a[i]);
        }
        sort ( nums.begin(), nums.end() );
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) {
                Insert(<span class="hljs-number">1</span>, n, root[i - <span class="hljs-number">1</span>], root[i], get_Id(a[i])); <span class="hljs-comment">// 插入，同时赋值第i个数形成的版本是几</span>
        }

        <span class="hljs-keyword">while</span> ( m -- ) {
                <span class="hljs-keyword">int</span> l, r, k; <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;
                <span class="hljs-built_in">cout</span> &lt;&lt; nums[Query(<span class="hljs-number">1</span>, n, root[l - <span class="hljs-number">1</span>], root[r], k) - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
    </body>
