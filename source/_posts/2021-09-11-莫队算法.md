---
layout: post
title: 莫队算法
subtitle: 离线操作啊，先保存后输出？🤔
categories: 数据结构
tags: [数据结构]
---

<head>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
	</style>
        <style>
		.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
	</style>
</head>
<body class="vscode-body vscode-light">
        <h2 id="普通莫队">普通莫队</h2>
<h3 id="问题类型">问题类型</h3>
<blockquote>
<p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span>个查询操作，没有修改操作，每次查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>有多少个不同的数</p>
</blockquote>
<h3 id="作用">作用</h3>
<p>可以解决<span style="color: red;">区间离线问题</span>的离线算法，如果在线可能会T掉<br>
时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> ，但可能会有出题人卡莫队</p>
<h3 id="优化策略">优化策略</h3>
<h4 id="双指针">双指针</h4>
<blockquote>
<p>给个数列有若干次询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">L</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 的区间和（强制莫队）</p>
<p>解：开个数组</p>
<table>
<thead>
<tr>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">7</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span></span></span></span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">7</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>若现在知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mclose">]</span></span></span></span> 区间和为18<br>
   求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">]</span></span></span></span> 的区间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.36687em;"></span><span class="strut bottom" style="height:0.36687em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⇒</span></span></span></span> 加上第6项的值<br>
   求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">4</span><span class="mclose">]</span></span></span></span> 的区间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.36687em;"></span><span class="strut bottom" style="height:0.36687em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⇒</span></span></span></span> 删掉第5项的值</p>
</blockquote>
<p>朴素来看，对于区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L, R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">L</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> :<ol>
<li>加上左边一格贡献: add(--l)</li>
<li>加上右边一格贡献: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mo>(</mo><mo>+</mo><mo>+</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">add(++r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord">+</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li>
<li>减去左边一格贡献: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mo>(</mo><mo>+</mo><mo>+</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sub(++l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mopen">(</span><span class="mord">+</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></li>
<li>减去右边一格贡献: sub(--r)</li></p>
</ol>
<h4 id="排序分块">排序分块</h4>
<blockquote>
<p>若询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span> 次，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">[1,2],\;[n-1,n],\;[1,2],\;[n-1,n],\;[1,2].....</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span></span></span></span> ，上面的方法就变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
<p>可以改成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mspace width="0.277778em"></mspace><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">[1,2],\;[1,2],\;[1,2],\;[n-1,n],\;[n-1,n]\;[n-1,n]...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mord mspace thickspace"></span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span></span></span></span></p>
</blockquote>
<p>这样将距离较近的区间放在一起，时间复杂度变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span></p>
<h3 id="算法架构">算法架构</h3>
<p>|--分块<br>
|--记录询问<br>
|--排序<br>
|--遍历询问<br>
|----若左边短，左指针向左加一个数<br>
|----若右边短，右指针向右加一个数<br>
|----若左边长，左指针向右减一个数<br>
|----若右边长，右指针向左减一个数<br>
|----记录答案存入新数组<br>
|--以新数组顺序输出</p>
<blockquote>
<p><a href="https://vjudge.net/problem/%E9%BB%91%E6%9A%97%E7%88%86%E7%82%B8-1878">黑暗爆炸-1878《HH的项链》</a></p>
</blockquote>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> pos[N];
<span class="hljs-keyword">int</span> a[N];
<span class="hljs-keyword">int</span> res[N];
<span class="hljs-keyword">int</span> RES;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Q</span>{</span>
        <span class="hljs-keyword">int</span> l, r, id;
}q[N];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>
        freopen(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
        freopen(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-comment">// n m l r</span>
        <span class="hljs-keyword">int</span> n, m, l, r;
        <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r;
        <span class="hljs-comment">// 分块</span>
        <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">sqrt</span>(n);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
                <span class="hljs-built_in">cin</span> &gt;&gt; a[i],
                pos[i] = i / len;
        <span class="hljs-comment">// 询问</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )
                <span class="hljs-built_in">cin</span> &gt;&gt; q[i].l &gt;&gt; q[i].r,
                q[i].id = i;
        <span class="hljs-comment">// 排序</span>
        sort (q, q + m, [](Q x, Q y){
                <span class="hljs-keyword">return</span> pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l];
        });
        <span class="hljs-comment">// 初始化为开区间</span>
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {
                <span class="hljs-comment">// 左边太短了，l向左加一格</span>
                <span class="hljs-keyword">while</span> ( q[i].l &lt; l ) Add ( -- l );
                <span class="hljs-comment">// 右边太短了，r向右加一格</span>
                <span class="hljs-keyword">while</span> ( q[i].r &gt; r ) Add ( ++ r );
                <span class="hljs-comment">// 左边太长了，l向右减一格</span>
                <span class="hljs-keyword">while</span> ( q[i].l &gt; l ) Sub ( ++ l );
                <span class="hljs-comment">// 右边太长了，r向左减一格</span>
                <span class="hljs-keyword">while</span> ( q[i].r &lt; r ) Sub ( -- r );
                <span class="hljs-comment">// 记录答案</span>
                res[q[i].id] = RES;
        }
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )
                <span class="hljs-built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h2 id="带修莫队">带修莫队</h2>
<h3 id="问题类型-1">问题类型</h3>
<blockquote>
<p>多了个修改的版本问题，类似于时间</p>
</blockquote>
<p>那么可以<span style="color: red;">加一维记录时间戳</span><br>
每次查询可以确定一下版本，即第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 次修改之后，第k+1次修改之前</p>
<h3 id="指针移动">指针移动</h3>
<p>在同版本下的移动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 可以是普通莫队<br>
在<span style="color: red;">跳版本</span>下移动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r, t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mclose">]</span></span></span></span> 要<span style="color: red;">考虑两种情况</span><br>
1.修改的数在区间外，不用理会<br>
2.修改的数在区间内，计数减一下修改前的数，再加一下修改后的数</p>
<h3 id="修改操作">修改操作</h3>
<p>可以把修改操作记录一个数组，每次修改的数组内存放这次修改的是什么数<br>
那么在指针移动的时候我们只需要将原位置的数和修改后的数<span style="color:red;">交换一下</span></p>
<h3 id="排序优先级">排序优先级</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span> 所在块编号， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> 所在块编号， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span> 顺着递增
块长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mroot><mrow><mi>n</mi><mi>t</mi></mrow><mrow><mn>3</mn></mrow></mroot><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt[3]{nt})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8925400000000001em;"></span><span class="strut bottom" style="height:1.1425400000000001em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="sqrt mord"><span class="root"><span class="vlist"><span style="top:-0.4470480000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sqrt-sign" style="top:-0.05254000000000003em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span><span style="top:-0.81254em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="思想总结">思想总结</h3>
<p>带修莫队多了个<span style="color:red;">时间戳</span>的移动<br>
也可以被视作第三个指针<br>
其中可以做也是必做的优化就是我们再修改的的时候记录操作而不是直接修改，因为时间戳指针可能会来回折返，我们要知道下一步要改成什么<br>
在移动时间戳时，走过某个修改时只需要将修改的值和原始值调换一下<br>
如果在区间外也要交换，因为之后遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">L</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 也会走过去</p>
<h3 id="算法架构-1">算法架构</h3>
<p>|--记录查询<br>
|--记录修改<br>
|--对查询排序<br>
|--三个指针
|----左右指针在一个版本内跑来固定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>q</mi><mi mathvariant="normal">.</mi><mi>l</mi><mo separator="true">,</mo><mi>q</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[q.l,q.r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间
|----版本指针在多个版本上跳
|------交换修改的数和原数
|------判断这个版本修改是否在左右指针那，看看需不需要修改当前RES
|--录入答案
|--输出</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1903">洛谷-P1903《[国家集训队]数颜色 / 维护队列》</a></p>
</blockquote>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;

<span class="hljs-keyword">int</span> cnt[M], a[N], res[N], pos[N];
<span class="hljs-keyword">int</span> n, m, len;
<span class="hljs-keyword">int</span> nq, nm, RES;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Q</span>{</span>
	<span class="hljs-keyword">int</span> l, r, t, id;
}qry[N];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">M</span>{</span>
	<span class="hljs-keyword">int</span> x, y;
}mdf[N];

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{
	RES += ! cnt[x] ++;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sub</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{
	RES -= ! -- cnt[x];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);
	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);
	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ ) {
		<span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> x, y;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;x, &amp;y);
		<span class="hljs-keyword">if</span> ( op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span> ) ++ nq, qry[nq] = { x, y, nm, nq };
		<span class="hljs-keyword">else</span>                ++ nm, mdf[nm] = { x, y };
	} 
	len = cbrt ((<span class="hljs-keyword">double</span>)n * nm) + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ ) 
		pos[i] = i / len;
	sort ( qry + <span class="hljs-number">1</span>, qry + <span class="hljs-number">1</span> + nm, [&amp;]( Q a, Q b ){
		<span class="hljs-keyword">if</span> ( pos[a.l] != pos[b.l] ) <span class="hljs-keyword">return</span> pos[a.l] &lt; pos[b.l];
		<span class="hljs-keyword">if</span> ( pos[a.r] != pos[b.r] ) <span class="hljs-keyword">return</span> pos[a.r] &lt; pos[b.r];
		<span class="hljs-keyword">if</span> ( pos[a.r] &amp; <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> a.t &gt; b.t;
		<span class="hljs-keyword">return</span> a.t &lt; b.t;		
	});
	
	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>, T = <span class="hljs-number">0</span>, k = <span class="hljs-number">1</span>; k &lt;= nq; k ++ ) {
		<span class="hljs-keyword">while</span> ( L &lt; qry[k].l ) sub ( a[L ++] );
		<span class="hljs-keyword">while</span> ( L &gt; qry[k].l ) add ( a[-- L] );
		<span class="hljs-keyword">while</span> ( R &lt; qry[k].r ) add ( a[++ R] );
		<span class="hljs-keyword">while</span> ( R &gt; qry[k].r ) sub ( a[R --] );
		<span class="hljs-keyword">while</span> ( T != qry[k].t ) {
			<span class="hljs-keyword">if</span> ( T &lt; qry[k].t ) T ++;
			<span class="hljs-keyword">if</span> ( L &lt;= mdf[T].x &amp;&amp; mdf[T].x &lt;= R ) 
				sub ( a[mdf[T].x] ),
				add ( mdf[T].y );
			swap ( a[mdf[T].x], mdf[T].y );
			<span class="hljs-keyword">if</span> ( T &gt; qry[k].t ) T --;
		}
		res[qry[k].id] = RES;
	}
	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nq; i ++ ) 
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res[i]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="回滚莫队">回滚莫队</h2>
<h3 id="问题类型-2">问题类型</h3>
<blockquote>
<p>给定一个数列，多个查询区间新定义的最大值<br>
这种好增加<span style="color: red;">不好删除</span>的问题</p>
</blockquote>
<p>我们可以<span style="color: red;">全使用增加操作</span>来进行跑指针</p>
<h3 id="新遍历方法">新遍历方法</h3>
<p>我们在回滚莫队中一次考虑一整个块其中所有的询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>在该块内点询问<br>
这些询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>递增</p>
<h3 id="分类讨论">分类讨论</h3>
<p>这样遍历时会出现两种情况：<br>
1.开始时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>在同一个块内<br>
2.后面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>不在同一个块内</p>
<p><strong>情况1：</strong><br>
由于一个块内长度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="sqrt mord"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> ，所以<span style="color: red;">直接暴力</span>即可<br>
但这波暴力是没有收益点，只能用来记一下答案，遍历完要清一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组<br>
<strong>情况2：</strong><br>
我们将查询的区间<span style="color:red;">分为两部分</span><br>
1.在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>所在的块内<br>
对于这部分同样我们可以暴力解决，结束了也要清一下数组<br>
2.不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>所在的块内<br>
这样的所有区间左端点都固定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>的下一个块的第一个位置<br>
这些区间遍历时只前进右端点<br>
我们完全可以只使用莫队的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span></span></span></span> 操作来实现</p>
<h3 id="思想总结-1">思想总结</h3>
<p>既然使用删除操作很麻烦，那么就不使用删除操作<br>
对于一个短到一个块内的区间，直接使用暴力求解<br>
对于跨区间的块，将其按左端点块编号分类之后，可以将同一类的每个区间分为左边的不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="sqrt mord"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> 的小区间和右边不断前进的大区间，左边暴力右边莫队即可解决问题</p>
<h3 id="算法架构-2">算法架构</h3>
<p>|--读入数据、排序询问<br>
|--遍历询问<br>
|----开始时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>=</mo><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">get(l)=get(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> ，直接暴力<br>
|----后面时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>≠</mo><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">get(l)\neq get(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><br>
|------对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">get(l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span> 块下的部分区间进行暴力<br>
|------对其余部分区间进行莫队递进 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span></span></span></span><br>
|--输出答案</p>
<blockquote>
<p><a href="">洛谷-P5906《【模板】回滚莫队&amp;不删除莫队》</a></p>
</blockquote>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> n, m, len;
<span class="hljs-keyword">int</span> w[N], cnt[N];
ll res[N];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Q</span>{</span>
        <span class="hljs-keyword">int</span> id, l, r;
}q[N];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{ <span class="hljs-keyword">return</span> x / len;}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x, ll &amp;RES )</span> </span>{
        cnt[x] ++;
        RES = max ( RES, (ll)cnt[x] * nums[x] );
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>
        freopen(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
        freopen(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); len = <span class="hljs-built_in">sqrt</span>(n);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) 
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]), 
                nums.push_back(w[i]);

        <span class="hljs-comment">//离散化</span>
        sort ( nums.begin(), nums.end() );
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) 
                w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin(); 
        
        <span class="hljs-comment">// 询问读入与排序</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {
                <span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);
                q[i] = {i, l, r};
        }
        
        sort ( q, q + m, [] ( Q a, Q b ) {
                <span class="hljs-keyword">if</span> ( get(a.l) != get(b.l) ) <span class="hljs-keyword">return</span> get(a.l) &lt; get(b.l);
                <span class="hljs-keyword">return</span> a.r &lt; b.r;
        });

        <span class="hljs-comment">// 遍历询问</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; m; ) {
                <span class="hljs-keyword">int</span> y = x;
                <span class="hljs-keyword">while</span> ( y &lt; m &amp;&amp; get(q[y].l) == get(q[x].l) ) y ++; <span class="hljs-comment">// [x,y-1]的区间内都是.l相等的查询</span>
                <span class="hljs-keyword">int</span> right = get(q[x].l) * len + len - <span class="hljs-number">1</span>; <span class="hljs-comment">// q[x].l所在的块的最后一个点</span>

                <span class="hljs-comment">// q[x].l和q[x].r在同一个块内，直接暴力求</span>
                <span class="hljs-keyword">while</span> ( x &lt; y &amp;&amp; q[x].r &lt;= right ) { 
                        ll RES = <span class="hljs-number">0</span>; 
                        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = q[x].l; k &lt;= q[x].r; k ++ ) add ( w[k], RES );
                        res[q[x].id] = RES;
                        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = q[x].l; k &lt;= q[x].r; k ++ ) cnt[w[k]] --; <span class="hljs-comment">// 回到更新前的数据状态</span>
                        x ++;
                }
                
                <span class="hljs-comment">// 求在不同块内的询问</span>
                ll RES = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">int</span> i = right, j = right + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右端点和左端点</span>
                <span class="hljs-keyword">while</span> ( x &lt; y ) {
                        <span class="hljs-keyword">while</span> ( i &lt; q[x].r ) add ( w[ ++ i ], RES ); <span class="hljs-comment">// 右端点移动到正确的位置</span>
                        ll backup = RES; <span class="hljs-comment">// 备份一下</span>
                        <span class="hljs-keyword">while</span> ( j &gt; q[x].l ) add ( w[ -- j ], RES ); <span class="hljs-comment">// 左端点移动到正确的位置</span>
                        res[q[x].id] = RES;
                        <span class="hljs-keyword">while</span> ( j &lt; right + <span class="hljs-number">1</span> ) cnt[w[j ++]] --; <span class="hljs-comment">// 左侧回到更新前的数据状态，因为左侧不删要重开</span>
                        RES = backup; <span class="hljs-comment">// 恢复备份</span>
                        x ++;
                }
                <span class="hljs-built_in">memset</span> ( cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> cnt ); <span class="hljs-comment">// 进行下一部分的查询前要清空</span>
        }
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res[i]);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="树上莫队">树上莫队</h2>
<h3 id="问题类型-3">问题类型</h3>
<p>给一个无根普通树，若干询问，树的某条路径上一共有多少种不同权重
<img src="https://i.loli.net/2021/09/11/eCVfYKyq9wjRgWE.png">
权值：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>45</td>
<td>2</td>
<td>9</td>
<td>1</td>
<td>8</td>
<td>5</td>
<td>7</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>树上的修改问题，可以变成一个线性区间修改问题<br>
在这里可以使用欧拉序列</p>
<h3 id="欧拉序列">欧拉序列</h3>
<h4 id="构造方式">构造方式</h4>
<p><strong><span style="color: red;">对树DFS一次，正序遍历到每个节点时记录一次，后序遍历再记录一次</span></strong><br>
<span style="color:blue;">比如上面的树可以变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">7</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">7</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></p>
<h4 id="性质">性质</h4>
<p>1.每个点进入写一次，离开写一次，共写两次<br>
2.每次询问路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>→</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x\rightarrow y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 选序列中x最开始(最后)出现的位置和y最开始出现的位置，只保留中间出现过一次的数</p>
<h4 id="操作方式">操作方式</h4>
<p>两个数组<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">first[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">u</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 第一次出现的位置<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">last[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">u</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 第二次出现的位置<br>
选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 之前出现，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>&lt;</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">first[x]\lt first[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<h3 id="分类讨论-1">分类讨论</h3>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">lca(x,y)=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> ，则欧拉序列中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>→</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">first[x]\rightarrow first[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 中间只出现一次的点对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 的路径<span style="color: blue">（因为若出现0次说明没搜到，若出现两次说明进去搜了但是不存在</span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>≠</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">lca(x,y)\neq x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathit">x</span></span></span></span> ，则路径对应欧拉序列中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>→</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">last[x]\rightarrow first[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 中只出现一次的点以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> <span style="color: blue;">（因为最后的lca仍未回溯</span></li>
</ol>
<h3 id="指针移动-1">指针移动</h3>
<p>三个数组<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 记录权值出现的个数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">st[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 记录序号出现的次数(0/1)，<span style="color: red;">更新： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><msup><mo>]</mo><mo>=</mo></msup><mn>1</mn></mrow><annotation encoding="application/x-tex">st[]^=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mrel">=</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">1</span></span></span></span> </span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span> 实时记录答案</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">( x )</span> </span>{
        st[x] ^= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( st[x] == <span class="hljs-number">0</span> ) res -= ! -- cnt[a[x]];
        <span class="hljs-keyword">else</span>              res -= ! cnt[a[x]] --;
}
</div></code></pre>
<p>由于减去一个数也是异或1，所以一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span></span></span></span> 就够用了</p>
<h3 id="思想总结-2">思想总结</h3>
<p>对于一个树上问题，我们主要利用欧拉序列把它变成区间问题<br>
然后对于欧拉序列性质（有关lca），我们可以得出我们每次要固定哪个区间和哪些数</p>
<h3 id="算法架构-3">算法架构</h3>
<p>|--求欧拉序列<br>
|--求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">a</span></span></span></span><br>
|----预处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mo>]</mo><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[][]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span><br>
|----倍增向上跳找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">a</span></span></span></span><br>
|--树上询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.36687em;"></span><span class="strut bottom" style="height:0.36687em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> 序列询问<br>
|--莫队</p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/2536/">AcWing-2534 《树上计数2》</a></p>
</blockquote>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;

<span class="hljs-keyword">int</span> n, m, len;
<span class="hljs-keyword">int</span> w[N]; <span class="hljs-comment">// 读入点权</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span> <span class="hljs-keyword">int</span> nxt, to; } edge[N]; <span class="hljs-keyword">int</span> head[N], tot; 
<span class="hljs-keyword">int</span> depth[N], f[N][<span class="hljs-number">16</span>]; <span class="hljs-comment">// 倍增lca那一套</span>
<span class="hljs-keyword">int</span> seq[N], top, first[N], last[N]; <span class="hljs-comment">// 欧拉序列，当前位置出现的个数，最早出现的位置和最后出现的位置</span>
<span class="hljs-keyword">int</span> cnt[N], st[N], res[N]; <span class="hljs-comment">// 权值不同个数，序号出现的个数（奇数/偶数），答案记录</span>
<span class="hljs-keyword">int</span> que[N]; <span class="hljs-comment">// 宽搜队列</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qry</span> {</span>
        <span class="hljs-keyword">int</span> id, l, r; <span class="hljs-comment">// 第id个查询，查询区间是l, r</span>
        <span class="hljs-keyword">int</span> p; <span class="hljs-comment">// 有无最近公共祖先</span>
}q[N];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums; <span class="hljs-comment">// 离散化</span>
<span class="hljs-keyword">int</span> RES; <span class="hljs-comment">// 答案实时计数</span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add_Edge</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to )</span> </span>{
        edge[ ++ tot ] = {head[from], to};
        head[from] = tot;
}

<span class="hljs-comment">// -----------------------------------------------------------------求欧拉序列</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> father )</span> </span>{
        seq[ ++ top ] = u;
        first[u] = top;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = head[u]; ~i; i = edge[i].nxt ) {
                <span class="hljs-keyword">int</span> j = edge[i].to;
                <span class="hljs-keyword">if</span> ( j != father ) dfs ( j, u );
        } 
        seq[ ++ top ] = u;
        last[u] = top;
}
<span class="hljs-comment">// ---------------------------------------------------------------------------</span>

<span class="hljs-comment">// -------------------------------------------------------------------预处理倍增lca</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lca</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span> </span>{
        <span class="hljs-keyword">if</span> ( depth[a] &lt; depth[b] ) swap ( a, b );
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- ) 
                <span class="hljs-keyword">if</span> ( depth[f[a][k]] &gt;= depth[b] ) 
                        a = f[a][k];
        <span class="hljs-keyword">if</span> ( a == b ) <span class="hljs-keyword">return</span> a;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- ) 
                <span class="hljs-keyword">if</span> ( f[a][k] != f[b][k] ) 
                        a = f[a][k],
                        b = f[b][k];
        <span class="hljs-keyword">return</span> f[a][<span class="hljs-number">0</span>];
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">memset</span> ( depth, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> depth );
        depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;
        que[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> ( hh &lt;= tt ) {
                <span class="hljs-keyword">int</span> t = que[hh ++ ];
                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = head[t]; ~i; i = edge[i].nxt ) {
                        <span class="hljs-keyword">int</span> to = edge[i].to;
                        <span class="hljs-keyword">if</span> ( depth[to] &gt; depth[t] + <span class="hljs-number">1</span> ) {
                                depth[to] = depth[t] + <span class="hljs-number">1</span>;
                                f[to][<span class="hljs-number">0</span>] = t;
                                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">15</span>; k ++ ) {
                                        f[to][k] = f[f[to][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];
                                }
                                que[ ++ tt ] = to;
                        }
                }
        }
}
<span class="hljs-comment">// ------------------------------------------------------------------------------------</span>

<span class="hljs-comment">// ----------------------------------------------------------------------------- 莫队操作</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{ <span class="hljs-keyword">return</span> x / len; }

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{
        st[x] ^= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( st[x] == <span class="hljs-number">0</span> ) {
                cnt[w[x]] --;
                <span class="hljs-keyword">if</span> ( !cnt[w[x]] ) RES --;
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> ( !cnt[w[x]] ) RES ++;
                cnt[w[x]] ++;
        }
}
<span class="hljs-comment">// ------------------------------------------------------------------------------------</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>
        freopen(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
        freopen(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-comment">// 读入数据并进行离散化</span>
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) 
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]), 
                nums.push_back(w[i]);
        sort ( nums.begin(), nums.end() );
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) {
                w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();
        }

        <span class="hljs-comment">// 建图</span>
        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ ) {
                <span class="hljs-keyword">int</span> a, b; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);
                Add_Edge ( a, b );
                Add_Edge ( b, a );
        }

        <span class="hljs-comment">// 求欧拉序列</span>
        dfs ( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> );
        <span class="hljs-comment">// 预处理最近公共祖先</span>
        bfs ();
        
        <span class="hljs-comment">// 询问</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {
                <span class="hljs-keyword">int</span> a, b; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b); 
                <span class="hljs-comment">// 转移成线性区间问题</span>
                <span class="hljs-keyword">if</span> ( first[a] &gt; first[b] ) swap ( a, b );
                <span class="hljs-keyword">int</span> p = lca ( a, b );
                <span class="hljs-keyword">if</span> ( a == p ) q[i] = {i, first[a], first[b]};
                <span class="hljs-keyword">else</span> q[i] = {i, last[a], first[b], p};
        }

        <span class="hljs-comment">// 分块排序</span>
        len = <span class="hljs-built_in">sqrt</span> ( top );
        sort ( q, q + m, [&amp;]( Qry a, Qry b ) {
                <span class="hljs-keyword">if</span> ( get(a.l) != get(b.l) ) <span class="hljs-keyword">return</span> get(a.l) &lt; get(b.l);
                <span class="hljs-keyword">if</span> ( get(a.l) &amp; <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> a.r &lt; b.r;
                <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> a.r &gt; b.r;
        });
        
        <span class="hljs-comment">// 莫队指针操作</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {
                <span class="hljs-keyword">int</span> id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;
                <span class="hljs-keyword">while</span> ( R &lt; r ) add ( seq[ ++ R ] );
                <span class="hljs-keyword">while</span> ( R &gt; r ) add ( seq[ R -- ] );
                <span class="hljs-keyword">while</span> ( L &lt; l ) add ( seq[ L ++ ] );
                <span class="hljs-keyword">while</span> ( L &gt; l ) add ( seq[ -- L ] );
                <span class="hljs-keyword">if</span> ( p ) add ( p ); <span class="hljs-comment">// 如果x不是y的公共祖先的话要先加上再减去</span>
                res[id] = RES;
                <span class="hljs-keyword">if</span> ( p ) add ( p );
        }

        <span class="hljs-comment">// 输出答案</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) 
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res[i]);

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="二次离线莫队">二次离线莫队</h2>
<h3 id="问题类型-4">问题类型</h3>
<blockquote>
<p>定义一个新的配对含义：两个数异或后二进制表示有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>
长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的序列，一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span> 次询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 内有多少个数对配对<br>
这类问题每次指针移动之后对数据的修改值非常难算</p>
</blockquote>
<p>这类问题可以把一个问题推导成两个问题，一个问题使用莫队离线直接算出后，对另一个问题再拎出来离线算一次</p>
<h3 id="遍历分类">遍历分类</h3>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mspace width="0.277778em"></mspace><mi>R</mi><mo>⟶</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,\;R\longrightarrow r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">L</span><span class="mpunct">,</span><span class="mord mspace thickspace"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">⟶</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p>
<p>原是思想是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> 向后移动并加入一个数，看<span style="color:red;">加入的这个数对答案会不会产生什么价值或影响</span><br>
在这里加入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span> 时，看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span> 这个位置上的数能和原区间内多少个元素<span style="color:red;">产生配对</span></p>
<p>我们令  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>  表示  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>  中多少个数与  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>  位置配对，则上问题的求法就是<span style="color:red;"> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo><mo>−</mo><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[R]-S[L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> </span></p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mn>1</mn><mo>]</mo><mtext> </mtext><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[1]~w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mord mspace"> </span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 中有多少个数与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 配对，所以问题关键指向<span style="color: red;">预处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> </span><br>
设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个数中有多少个与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 配对，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>g</mi><mo>[</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]=g[w[i+1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
对于每次加入一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">w[i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span></span></span></span> 我们要寻找哪些数和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 配对，让他们的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mo>)</mo><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">g()++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord">+</span></span></span></span><br>
所以我们要建一个数组存放所有存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 的数<br>
要找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>⊗</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>⇒</mo><mi>x</mi><mo>=</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>⊗</mo><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i]\otimes x=y[i]\Rightarrow x=w[i]\otimes y[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mbin">⊗</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">⇒</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mbin">⊗</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 遍历所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">y[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span> 要加的数，所以是对<span style="color: red;"> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>⊗</mo><mi>y</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">g[w[i]\otimes y[i]]++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mbin">⊗</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mbin">+</span><span class="mord">+</span></span></span></span> </span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 这么求，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 也出来了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\therefore S[R]=f[R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mrel amsrm">∴</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span>离线求</p>
<p>我们在推 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>→</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">R\rightarrow r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> 时，每个数加进来都求一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span><br>
那么就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 每次都配对一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[R+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的数<br>
可将这些问题拿出来，每个问题：某个固定前缀中，某个区间每个数和这个前缀中多少个数配对<br>
从前往后求前缀即前缀是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>的哪些询问可以干掉，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span>的哪些询问可以干掉，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span>的，......<br>
这些都可以离线做一遍出来</p>
<p>那么第一次离线得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> ，再离线一次统一出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span><br>
<span style="color: red;">注：每次求的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">S[R-S[L-1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathit">L</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 是增量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span></span></span></span> 的数值</span></p>
<blockquote>
<p>对于其他的分类讨论情况也同理</p>
</blockquote>
<h3 id="算法框架">算法框架</h3>
<p>|--问题推导转化，做一个前缀和分成两个问题去解<br>
|--读入数据读入询问排序<br>
|--遍历<br>
|----第一次莫队遍历求第一个问题<br>
|----第二次顺序遍历求第二个问题<br>
|--合并答案输出</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4887">【模板】莫队二次离线（第十四分块(前体)）</a></p>
</blockquote>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-keyword">int</span> n, m, k, len;
<span class="hljs-keyword">int</span> w[N];
ll res[N];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Q</span> {</span>
        <span class="hljs-keyword">int</span> id, l, r;
        ll RES; <span class="hljs-comment">// 先存一下，分成两次求得</span>
} q[N];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Range</span> {</span> <span class="hljs-comment">// 待解决问题</span>
        <span class="hljs-keyword">int</span> id, l, r;
        <span class="hljs-keyword">int</span> t; <span class="hljs-comment">// 判断要加还是减</span>
};
<span class="hljs-built_in">vector</span>&lt;Range&gt; range[N]; <span class="hljs-comment">// 对于每个前缀可能会有多个询问区间</span>
<span class="hljs-keyword">int</span> f[N], g[N]; <span class="hljs-comment">// 推的公式关系的需要的数组</span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{ <span class="hljs-keyword">return</span> x / len; }

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_count</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> x )</span> </span>{ <span class="hljs-comment">// 有多少个1</span>
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> ( x ) res += x &amp; <span class="hljs-number">1</span>, x &gt;&gt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>
        freopen(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
        freopen(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);
        
        <span class="hljs-comment">// 存放所有有k个1的数</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums; 
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>; i ++ )
                <span class="hljs-keyword">if</span> ( get_count(i) == k ) 
                        nums.push_back(i);
        
        <span class="hljs-comment">// 初始化fg数组</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) {
                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> x : nums ) g[w[i] ^ x] ++; <span class="hljs-comment">// 求当前新加的这个数（w[i]）对于哪些x是有影响的</span>
                f[i] = g[w[i + <span class="hljs-number">1</span>]]; <span class="hljs-comment">// 公式关系</span>
        }

        <span class="hljs-comment">// 读入询问，排序</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {
                <span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;
                q[i] = {i, l, r};
        }
        len = <span class="hljs-built_in">sqrt</span> ( n );
        sort ( q, q + m, [] ( Q a ,Q b ) {
                <span class="hljs-keyword">if</span> ( get(a.l) != get(b.l) ) <span class="hljs-keyword">return</span> get(a.l) &lt; get(b.l);
                <span class="hljs-keyword">return</span> a.r &lt; b.r;
        });

        <span class="hljs-comment">// 莫队</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>; i &lt; m; i ++ ) {

                <span class="hljs-comment">// S_R - S_{L - 1}</span>
                <span class="hljs-keyword">if</span> ( R &lt; q[i].r ) range[L - <span class="hljs-number">1</span>].push_back({i, R + <span class="hljs-number">1</span>, q[i].r, <span class="hljs-number">-1</span>}); <span class="hljs-comment">// [R + 1, r] 先不处理，加入询问</span>
                <span class="hljs-keyword">while</span> ( R &lt; q[i].r ) q[i].RES += f[ R ++ ];

                <span class="hljs-comment">// - ( S_{R - 1} - S_{L - 1} )</span>
                <span class="hljs-keyword">if</span> ( R &gt; q[i].r ) range[L - <span class="hljs-number">1</span>].push_back({i, q[i].r + <span class="hljs-number">1</span>, R, <span class="hljs-number">1</span>}); <span class="hljs-comment">// [r + 1, R] 先不处理， 加入询问</span>
                <span class="hljs-keyword">while</span> ( R &gt; q[i].r ) q[i].RES -= f[ -- R ];

                <span class="hljs-comment">// - ( S_R - S_L )</span>
                <span class="hljs-keyword">if</span> ( L &lt; q[i].l ) range[R].push_back({i, L, q[i].l - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>}); <span class="hljs-comment">// [L, l - 1] 先不处理， 加入询问</span>
                <span class="hljs-keyword">while</span> ( L &lt; q[i].l ) q[i].RES += f[L - <span class="hljs-number">1</span>] + !k, L ++; <span class="hljs-comment">// 因为存的是[1, L - 1]有多少个与L配对，所以要多加个判断w_L是否配对(k!=0)</span>

                <span class="hljs-keyword">if</span> ( L &gt; q[i].l ) range[R].push_back({i, q[i].l, L - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>}); <span class="hljs-comment">// [l, L - 1] 先不处理， 加入询问</span>
                <span class="hljs-keyword">while</span> ( L &gt; q[i].l ) q[i].RES -= f[L - <span class="hljs-number">2</span>] + !k, L --;
        }

        <span class="hljs-comment">// 整体求一下没求的部分</span>
        <span class="hljs-built_in">memset</span> ( g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g );
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) { <span class="hljs-comment">// 枚举每个前缀</span>
                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> x : nums ) g[w[i] ^ x] ++; <span class="hljs-comment">// 枚举所有满足要求的y</span>
                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span>&amp; rg : range[i] ) {
                        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> x = rg.l; x &lt;= rg.r; x ++ )
                                q[rg.id].RES += g[w[x]] * rg.t;
                }
        }

        <span class="hljs-comment">// 因为每次求的是增量，所以要累加前缀和</span>
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i ++ ) q[i].RES += q[i - <span class="hljs-number">1</span>].RES;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) res[q[i].id] = q[i].RES;


        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res[i]);
}
</div></code></pre>
    </body>
